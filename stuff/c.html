<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/mvg/doc/PAMI-2020-chicago/src/PLMP/CODE/common.m2.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="m2">
<meta name="settings" content="number_lines,use_css,pre_wrap,no_foldcolumn,expand_tabs,line_ids,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="solarized">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #839496; background-color: #002b36; }
body { font-family: monospace; color: #839496; background-color: #002b36; }
* { font-size: 1em; }
.Identifier { color: #268bd2; }
.Constant { color: #2aa198; }
.LineNr { color: #505050; background-color: #073642; padding-bottom: 1px; }
.Statement { color: #859900; }
.Comment { color: #586e75; }
.Type { color: #b58900; }
-->
</style>

<script>
<!--

/* function to open any folds containing a jumped-to line before jumping to it */
function JumpToLine()
{
  var lineNum;
  lineNum = window.location.hash;
  lineNum = lineNum.substr(1); /* strip off '#' */

  if (lineNum.indexOf('L') == -1) {
    lineNum = 'L'+lineNum;
  }
  var lineElem = document.getElementById(lineNum);
  /* Always jump to new location even if the line was hidden inside a fold, or
   * we corrected the raw number to a line ID.
   */
  if (lineElem) {
    lineElem.scrollIntoView(true);
  }
  return true;
}
if ('onhashchange' in window) {
  window.onhashchange = JumpToLine;
}

-->
</script>
</head>
<body onload='JumpToLine();'>
<pre id='vimCodeElement'>
<span id="L1" class="LineNr">  1 </span><span class="Comment">-- IMPORTS </span>
<span id="L2" class="LineNr">  2 </span><span class="Identifier">debug</span> <span class="Identifier">needsPackage</span> &quot;NumericalAlgebraicGeometry&quot;
<span id="L3" class="LineNr">  3 </span><span class="Identifier">debug</span> <span class="Identifier">needsPackage</span> &quot;MonodromySolver&quot;
<span id="L4" class="LineNr">  4 </span><span class="Identifier">debug</span> SLPexpressions
<span id="L5" class="LineNr">  5 </span><span class="Identifier">debug</span> <span class="Identifier">needsPackage</span> &quot;Core&quot;
<span id="L6" class="LineNr">  6 </span>
<span id="L7" class="LineNr">  7 </span><span class="Comment">-- FUNCTIONS</span>
<span id="L8" class="LineNr">  8 </span>
<span id="L9" class="LineNr">  9 </span><span class="Identifier">size</span> GateMatrix := M -&gt; (numrows M, numcols M)
<span id="L10" class="LineNr"> 10 </span><span class="Identifier">size</span> <span class="Type">Matrix</span> := M -&gt; (numrows M, numcols M)
<span id="L11" class="LineNr"> 11 </span>
<span id="L12" class="LineNr"> 12 </span>-*
<span id="L13" class="LineNr"> 13 </span><span class="Comment">-- evaluate a gateMatrix G at a matrix x</span>
<span id="L14" class="LineNr"> 14 </span><span class="Comment">-- don't use this a lot...</span>
<span id="L15" class="LineNr"> 15 </span>evaluate (GateMatrix, <span class="Type">Matrix</span>) := (G, x) -&gt; (
<span id="L16" class="LineNr"> 16 </span>    M := <span class="Identifier">mutableMatrix</span>(FF,numrows G,numcols G);
<span id="L17" class="LineNr"> 17 </span>    E' := makeEvaluator(G,<span class="Identifier">matrix</span>{cameraVars|dataParams});
<span id="L18" class="LineNr"> 18 </span>    evaluate(E',<span class="Identifier">mutableMatrix</span>(x),M);
<span id="L19" class="LineNr"> 19 </span>    <span class="Identifier">matrix</span> M
<span id="L20" class="LineNr"> 20 </span>    )
<span id="L21" class="LineNr"> 21 </span>*-
<span id="L22" class="LineNr"> 22 </span>
<span id="L23" class="LineNr"> 23 </span><span class="Comment">--random diagonal matrix</span>
<span id="L24" class="LineNr"> 24 </span>randDiag = n -&gt; <span class="Identifier">diagonalMatrix</span> <span class="Statement">for</span> i <span class="Statement">from</span> 1 <span class="Statement">to</span> n <span class="Statement">list</span> <span class="Identifier">random</span> <span class="Constant">CC</span>
<span id="L25" class="LineNr"> 25 </span>
<span id="L26" class="LineNr"> 26 </span>dehomogenize = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{})
<span id="L27" class="LineNr"> 27 </span>dehomogenize (<span class="Type">Matrix</span>, <span class="Constant">ZZ</span>) := o -&gt; (v, n) -&gt; (
<span id="L28" class="LineNr"> 28 </span>    <span class="Comment">--assumes column vector</span>
<span id="L29" class="LineNr"> 29 </span>    (1/v_(n, 0))*v^(<span class="Identifier">toList</span> <span class="Identifier">splice</span>(0..n-1,n+1..numrows v-1))
<span id="L30" class="LineNr"> 30 </span>    )
<span id="L31" class="LineNr"> 31 </span>dehomogenize <span class="Type">Matrix</span> := o -&gt; v -&gt; dehomogenize(v, numrows v -1)
<span id="L32" class="LineNr"> 32 </span>
<span id="L33" class="LineNr"> 33 </span>summary = L -&gt; (
<span id="L34" class="LineNr"> 34 </span>    n := #L;
<span id="L35" class="LineNr"> 35 </span>    H := <span class="Identifier">sort</span> L;
<span id="L36" class="LineNr"> 36 </span>    Q1 := (1/2) * (H#(<span class="Identifier">floor</span>((n-1)/3))+H#(<span class="Identifier">ceiling</span>((n-1)/3)));
<span id="L37" class="LineNr"> 37 </span>    med := (1/2) * (H#(<span class="Identifier">floor</span>((n-1)/2))+H#(<span class="Identifier">ceiling</span>((n-1)/2)));
<span id="L38" class="LineNr"> 38 </span>    Q3 := (1/2) * (H#(<span class="Identifier">floor</span>(2*(n-1)/3))+H#(<span class="Identifier">ceiling</span>(2*(n-1)/3)));
<span id="L39" class="LineNr"> 39 </span>    mean := (<span class="Identifier">sum</span> L)/n;
<span id="L40" class="LineNr"> 40 </span>    var := <span class="Identifier">sum</span>(L/(x-&gt; (x - mean)^2))/(n-1);
<span id="L41" class="LineNr"> 41 </span>    &lt;&lt; &quot;Min: &quot; &lt;&lt; <span class="Identifier">toString</span>(<span class="Identifier">min</span> L) &lt;&lt; endl;
<span id="L42" class="LineNr"> 42 </span>    &lt;&lt; &quot;1Q: &quot; &lt;&lt; <span class="Identifier">toString</span>(Q1) &lt;&lt; endl;
<span id="L43" class="LineNr"> 43 </span>    &lt;&lt; &quot;Med: &quot; &lt;&lt; <span class="Identifier">toString</span>(med) &lt;&lt; endl;
<span id="L44" class="LineNr"> 44 </span>    &lt;&lt; &quot;Avg: &quot; &lt;&lt; <span class="Identifier">toString</span>(sub(mean,<span class="Constant">RR</span>)) &lt;&lt; endl;
<span id="L45" class="LineNr"> 45 </span>    &lt;&lt; &quot;3Q: &quot; &lt;&lt; <span class="Identifier">toString</span>(Q3) &lt;&lt; endl;
<span id="L46" class="LineNr"> 46 </span>    &lt;&lt; &quot;Max: &quot; &lt;&lt; <span class="Identifier">toString</span>(<span class="Identifier">max</span> L) &lt;&lt; endl;
<span id="L47" class="LineNr"> 47 </span>    &lt;&lt; &quot;Std Dev: &quot; &lt;&lt; <span class="Identifier">toString</span>(<span class="Identifier">sqrt</span>(var)) &lt;&lt; endl;
<span id="L48" class="LineNr"> 48 </span>    )
<span id="L49" class="LineNr"> 49 </span>
<span id="L50" class="LineNr"> 50 </span><span class="Comment">-- random element in the kernel of M</span>
<span id="L51" class="LineNr"> 51 </span>randKernel = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Tolerance=&gt;1e-4})
<span id="L52" class="LineNr"> 52 </span>randKernel (<span class="Type">Matrix</span>, <span class="Type">InexactFieldFamily</span>) := o -&gt; (M, FF) -&gt; (
<span id="L53" class="LineNr"> 53 </span>    K := numericalKernel(M, o.Tolerance);
<span id="L54" class="LineNr"> 54 </span>    K*<span class="Identifier">random</span>(FF^(numcols K), FF^1)
<span id="L55" class="LineNr"> 55 </span>    )
<span id="L56" class="LineNr"> 56 </span>randKernel <span class="Type">Matrix</span> := o -&gt; M -&gt; randKernel(M, <span class="Constant">CC</span>)
<span id="L57" class="LineNr"> 57 </span>
<span id="L58" class="LineNr"> 58 </span>reshapeCol = p -&gt; <span class="Statement">if</span> (numrows p == 1) <span class="Statement">then</span> <span class="Identifier">transpose</span> p <span class="Statement">else</span> p
<span id="L59" class="LineNr"> 59 </span>reshapeRow = p -&gt; <span class="Statement">if</span> (numcols p == 1) <span class="Statement">then</span> <span class="Identifier">transpose</span> p <span class="Statement">else</span> p
<span id="L60" class="LineNr"> 60 </span>
<span id="L61" class="LineNr"> 61 </span><span class="Comment">-- RANDOMIZATION FOR PARAMETER POINT p</span>
<span id="L62" class="LineNr"> 62 </span><span class="Comment">-- assumes random CC has unit modulus!</span>
<span id="L63" class="LineNr"> 63 </span>gammify = <span class="Identifier">method</span>()
<span id="L64" class="LineNr"> 64 </span>gammify Point := p -&gt; gammify reshapeCol <span class="Identifier">matrix</span> p
<span id="L65" class="LineNr"> 65 </span>gammify <span class="Type">Matrix</span> := p -&gt; (
<span id="L66" class="LineNr"> 66 </span>    gammas := <span class="Statement">for</span> i <span class="Statement">from</span> 1 <span class="Statement">to</span> m*#indepLines <span class="Statement">list</span> <span class="Identifier">random</span> <span class="Constant">CC</span>;
<span id="L67" class="LineNr"> 67 </span>    indDiag := <span class="Identifier">flatten</span>(gammas/(g-&gt;{g,g,g}));
<span id="L68" class="LineNr"> 68 </span>    <span class="Comment">-- abstract to arbitrary diagram, number of cameras</span>
<span id="L69" class="LineNr"> 69 </span>    depWInd := depLines/(l-&gt;<span class="Identifier">first</span> <span class="Identifier">select</span>(1,<span class="Identifier">last</span> D,i-&gt;<span class="Identifier">member</span>(l,i)));
<span id="L70" class="LineNr"> 70 </span>    mfoldIntersections := <span class="Identifier">flatten</span>(depWInd/(l-&gt;<span class="Statement">for</span> i <span class="Statement">from</span> 0 <span class="Statement">to</span> m-1 <span class="Statement">list</span> l/(x-&gt;m*x+i)));
<span id="L71" class="LineNr"> 71 </span>    <span class="Comment">-- next line assumes indepenedent lines come first!</span>
<span id="L72" class="LineNr"> 72 </span>    depDiag := <span class="Identifier">flatten</span>(
<span id="L73" class="LineNr"> 73 </span>        mfoldIntersections/(ind -&gt; {
<span id="L74" class="LineNr"> 74 </span>            <span class="Identifier">conjugate</span> gammas#(ind#0),
<span id="L75" class="LineNr"> 75 </span>            <span class="Identifier">conjugate</span> gammas#(ind#1)
<span id="L76" class="LineNr"> 76 </span>            }
<span id="L77" class="LineNr"> 77 </span>        )
<span id="L78" class="LineNr"> 78 </span>    );
<span id="L79" class="LineNr"> 79 </span>    tChartdiag := <span class="Identifier">toList</span>((3*(m-1)+1):<span class="Identifier">random</span>(<span class="Constant">CC</span>)); <span class="Comment">-- t chart gamma</span>
<span id="L80" class="LineNr"> 80 </span>    qChartDiags := <span class="Identifier">flatten</span> <span class="Statement">for</span> i <span class="Statement">from</span> 0 <span class="Statement">to</span> m-2 <span class="Statement">list</span> <span class="Identifier">toList</span>(5:<span class="Identifier">random</span>(<span class="Constant">CC</span>));
<span id="L81" class="LineNr"> 81 </span>    p' := <span class="Identifier">diagonalMatrix</span>(indDiag|depDiag|tChartdiag|qChartDiags)*p;
<span id="L82" class="LineNr"> 82 </span>    p'
<span id="L83" class="LineNr"> 83 </span>    )
<span id="L84" class="LineNr"> 84 </span>
<span id="L85" class="LineNr"> 85 </span>
<span id="L86" class="LineNr"> 86 </span><span class="Comment">-- fold along rows</span>
<span id="L87" class="LineNr"> 87 </span>rfold = L -&gt; <span class="Statement">if</span> (#L ==0) <span class="Statement">then</span> <span class="Identifier">random</span>(FF^0,FF^0) <span class="Statement">else</span> <span class="Identifier">fold</span>(L, (a,b) -&gt; a||b)
<span id="L88" class="LineNr"> 88 </span>
<span id="L89" class="LineNr"> 89 </span><span class="Comment">-- fold along cols</span>
<span id="L90" class="LineNr"> 90 </span>cfold = L -&gt; <span class="Identifier">fold</span>(L, (a,b) -&gt; a|b)
<span id="L91" class="LineNr"> 91 </span>
<span id="L92" class="LineNr"> 92 </span>
<span id="L93" class="LineNr"> 93 </span><span class="Comment">-- write starting parameters and solutions to file</span>
<span id="L94" class="LineNr"> 94 </span>writeStartSys = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Filename=&gt;&quot;startSys&quot;})
<span id="L95" class="LineNr"> 95 </span>writeStartSys (<span class="Type">Matrix</span>, <span class="Type">List</span>) := o -&gt; (M, sols) -&gt; writeStartSys(point M, sols, o)
<span id="L96" class="LineNr"> 96 </span>writeStartSys (Point, <span class="Type">List</span>) := o -&gt; (p, sols) -&gt; (
<span id="L97" class="LineNr"> 97 </span>   <span class="Identifier">assert</span>(<span class="Identifier">instance</span>(o.Filename,<span class="Type">String</span>));
<span id="L98" class="LineNr"> 98 </span>   f := <span class="Identifier">openOut</span> o.Filename;
<span id="L99" class="LineNr"> 99 </span>   f &lt;&lt; &quot;Parameter <span class="Identifier">values</span>: &quot; &lt;&lt; endl;
<span id="L100" class="LineNr">100 </span>   f &lt;&lt; <span class="Identifier">toExternalString</span> p &lt;&lt; endl;
<span id="L101" class="LineNr">101 </span>   f &lt;&lt; &quot;Solutions : &quot; &lt;&lt; endl;
<span id="L102" class="LineNr">102 </span>   <span class="Statement">for</span> s <span class="Statement">in</span> sols <span class="Statement">do</span> f &lt;&lt; <span class="Identifier">toExternalString</span> s &lt;&lt; endl;
<span id="L103" class="LineNr">103 </span>   close f;
<span id="L104" class="LineNr">104 </span>   )
<span id="L105" class="LineNr">105 </span>
<span id="L106" class="LineNr">106 </span>readStartSys = filename -&gt; (
<span id="L107" class="LineNr">107 </span>    l := <span class="Identifier">separate</span>(&quot;\n&quot;, <span class="Identifier">get</span> filename);
<span id="L108" class="LineNr">108 </span>    p0 := <span class="Identifier">value</span> l#1;
<span id="L109" class="LineNr">109 </span>    sols := <span class="Statement">for</span> i <span class="Statement">from</span> 3 <span class="Statement">to</span> #l-2 <span class="Statement">list</span> <span class="Identifier">value</span> l#i;
<span id="L110" class="LineNr">110 </span>    (<span class="Identifier">transpose</span> <span class="Identifier">matrix</span> p0, sols/<span class="Identifier">matrix</span>/<span class="Identifier">transpose</span>)
<span id="L111" class="LineNr">111 </span>    )
<span id="L112" class="LineNr">112 </span>
<span id="L113" class="LineNr">113 </span><span class="Comment">-- for testing the contents of a start system file</span>
<span id="L114" class="LineNr">114 </span>startSysTester = (p,sols) -&gt; (
<span id="L115" class="LineNr">115 </span>    p0 := (<span class="Identifier">transpose</span> <span class="Identifier">matrix</span> V.BasePoint);
<span id="L116" class="LineNr">116 </span>    p1 := <span class="Identifier">random</span>(<span class="Constant">CC</span>^(#dataParams),<span class="Constant">CC</span>^1);
<span id="L117" class="LineNr">117 </span>    P01 = p0||p1;
<span id="L118" class="LineNr">118 </span>    Pspec01 := specialize(PH,P0);
<span id="L119" class="LineNr">119 </span>    target01 := trackHomotopy(Pspec01, sols);
<span id="L120" class="LineNr">120 </span>    Pspec10 := (gammify p1)|(gammify p0);
<span id="L121" class="LineNr">121 </span>    trackHomotopy(Pspec10, target01)
<span id="L122" class="LineNr">122 </span>    )
<span id="L123" class="LineNr">123 </span>
<span id="L124" class="LineNr">124 </span>
<span id="L125" class="LineNr">125 </span>adjugate = <span class="Identifier">method</span>()
<span id="L126" class="LineNr">126 </span>adjugate <span class="Type">Thing</span> := M -&gt; (
<span id="L127" class="LineNr">127 </span>    n := numcols M;
<span id="L128" class="LineNr">128 </span>    <span class="Identifier">assert</span>(n == numrows M);
<span id="L129" class="LineNr">129 </span>    <span class="Identifier">matrix</span> <span class="Identifier">table</span>(n,n,(i,j)-&gt;((-1)^(i+j))*det <span class="Identifier">submatrix</span>'(M,{j},{i}))
<span id="L130" class="LineNr">130 </span>    )
<span id="L131" class="LineNr">131 </span>
<span id="L132" class="LineNr">132 </span><span class="Comment">-- not printing to high precision -- deprecated?</span>
<span id="L133" class="LineNr">133 </span>sol2String = p -&gt; <span class="Identifier">replace</span>(&quot;\\{|\\}&quot;,&quot;&quot;,<span class="Identifier">toString</span> p.Coordinates)
<span id="L134" class="LineNr">134 </span>
<span id="L135" class="LineNr">135 </span><span class="Comment">-- produces gates for &quot;small&quot; determinants&quot;</span>
<span id="L136" class="LineNr">136 </span>det2 = M -&gt; M_(0,0)*M_(1,1)-M_(1,0)*M_(0,1)
<span id="L137" class="LineNr">137 </span>det3 = M -&gt; M_(0,0)*det2(M_{1,2}^{1,2})-M_(0,1)*det2(M_{0,2}^{1,2})+M_(0,2)*det2(M_{0,1}^{1,2})
<span id="L138" class="LineNr">138 </span>det4 = M -&gt; M_(0,0)*det3(M_{1,2,3}^{1,2,3})-M_(0,1)*det3(M_{0,2,3}^{1,2,3})+M_(0,2)*det3(M_{0,1,3}^{1,2,3})-M_(0,3)*det3(M_{0,1,2}^{1,2,3})
<span id="L139" class="LineNr">139 </span>
<span id="L140" class="LineNr">140 </span>laplaceDet = M -&gt; (
<span id="L141" class="LineNr">141 </span>    (m, n) := <span class="Identifier">size</span> M;
<span id="L142" class="LineNr">142 </span>    <span class="Statement">if</span> (m=!=n) <span class="Statement">then</span> <span class="Identifier">error</span>(&quot;<span class="Statement">not</span> square <span class="Identifier">matrix</span>&quot;)
<span id="L143" class="LineNr">143 </span>    <span class="Statement">else</span> <span class="Statement">if</span> (m&gt;5) <span class="Statement">then</span> <span class="Identifier">error</span>(&quot;no Laplace <span class="Statement">for</span> matrices larger than 4x4&quot;)
<span id="L144" class="LineNr">144 </span>    <span class="Statement">else</span> <span class="Statement">if</span> (m==2) <span class="Statement">then</span> det2 M
<span id="L145" class="LineNr">145 </span>    <span class="Statement">else</span> <span class="Statement">if</span> (m==3) <span class="Statement">then</span> det3 M
<span id="L146" class="LineNr">146 </span>    <span class="Statement">else</span> -* m==4 *- det4 M
<span id="L147" class="LineNr">147 </span>    )
<span id="L148" class="LineNr">148 </span>
<span id="L149" class="LineNr">149 </span><span class="Comment">-- jacobian of GateMatrix wrt. a list of inputGates</span>
<span id="L150" class="LineNr">150 </span><span class="Identifier">jacobian</span> (GateMatrix, <span class="Type">List</span>) := (F,inGates) -&gt; <span class="Identifier">fold</span>(<span class="Identifier">apply</span>(inGates,g-&gt;<span class="Identifier">diff</span>(g,F)),(a,b)-&gt;a|b)
<span id="L151" class="LineNr">151 </span>
<span id="L152" class="LineNr">152 </span><span class="Comment">-- get rotation matrix from cayley parameters</span>
<span id="L153" class="LineNr">153 </span>cay2R = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Normalized=&gt;<span class="Constant">false</span>})
<span id="L154" class="LineNr">154 </span>cay2R (<span class="Type">Thing</span>,<span class="Type">Thing</span>,<span class="Type">Thing</span>) := o -&gt; (X,Y,Z) -&gt; (
<span id="L155" class="LineNr">155 </span>    <span class="Statement">if</span> <span class="Identifier">instance</span>(X, <span class="Constant">RR</span>) <span class="Statement">then</span> x := X_CC <span class="Statement">else</span> x = X;
<span id="L156" class="LineNr">156 </span>    <span class="Statement">if</span> <span class="Identifier">instance</span>(Y, <span class="Constant">RR</span>) <span class="Statement">then</span> y := Y_CC <span class="Statement">else</span> y = Y;
<span id="L157" class="LineNr">157 </span>    <span class="Statement">if</span> <span class="Identifier">instance</span>(Z, <span class="Constant">RR</span>) <span class="Statement">then</span> z := Z_CC <span class="Statement">else</span> z = Z;
<span id="L158" class="LineNr">158 </span>    M := <span class="Identifier">matrix</span>{
<span id="L159" class="LineNr">159 </span>    {1+x*x-(y*y+z*z), 2*(x*y-z), 2*(x*z+y)},
<span id="L160" class="LineNr">160 </span>    {2*(x*y+z), 1+y^2-(x*x+z*z), 2*(y*z-x)},
<span id="L161" class="LineNr">161 </span>    {2*(x*z-y), 2*(y*z+x), 1 +z*z -(x*x+y*y)}
<span id="L162" class="LineNr">162 </span>        };
<span id="L163" class="LineNr">163 </span>    <span class="Statement">if</span> o.Normalized <span class="Statement">then</span> (1/(1+x^2+y^2+z^2)) * M <span class="Statement">else</span> M
<span id="L164" class="LineNr">164 </span>    )
<span id="L165" class="LineNr">165 </span>cay2R <span class="Type">List</span> := o -&gt; L -&gt; cay2R(L#0, L#1, L#2, o)
<span id="L166" class="LineNr">166 </span>
<span id="L167" class="LineNr">167 </span><span class="Comment">-- get Cayley parameters from rotation matrix</span>
<span id="L168" class="LineNr">168 </span>R2Cay = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{UnNormalize=&gt;<span class="Constant">false</span>})
<span id="L169" class="LineNr">169 </span>R2Cay <span class="Type">Matrix</span> := o -&gt; R -&gt; (
<span id="L170" class="LineNr">170 </span>    <span class="Identifier">assert</span>(numcols R == 3);
<span id="L171" class="LineNr">171 </span>    <span class="Identifier">assert</span>(numrows R == 3);
<span id="L172" class="LineNr">172 </span>    S := (R-id_(<span class="Constant">CC</span>^3))*(R+id_(<span class="Constant">CC</span>^3))^-1;
<span id="L173" class="LineNr">173 </span>    (S_(2,1), S_(0,2), S_(1,0))
<span id="L174" class="LineNr">174 </span>    )
<span id="L175" class="LineNr">175 </span>
<span id="L176" class="LineNr">176 </span>-*/// <span class="Identifier">TEST</span>
<span id="L177" class="LineNr">177 </span><span class="Identifier">restart</span>
<span id="L178" class="LineNr">178 </span><span class="Identifier">needs</span> &quot;common.m2&quot;
<span id="L179" class="LineNr">179 </span>(x, y, z) = (<span class="Identifier">random</span> <span class="Constant">RR</span>, <span class="Identifier">random</span> <span class="Constant">RR</span>, <span class="Identifier">random</span> <span class="Constant">RR</span>)
<span id="L180" class="LineNr">180 </span>R = cay2R(x, y, z)
<span id="L181" class="LineNr">181 </span>(x',y',z') = R2Cay R
<span id="L182" class="LineNr">182 </span>R = cay2R(x', y', z')
<span id="L183" class="LineNr">183 </span>R2Cay R
<span id="L184" class="LineNr">184 </span>///*-
<span id="L185" class="LineNr">185 </span>
<span id="L186" class="LineNr">186 </span><span class="Comment">-- get rotation matrix from quaternion parameters</span>
<span id="L187" class="LineNr">187 </span>Q2R = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Normalized=&gt;<span class="Constant">false</span>, FF=&gt;<span class="Constant">CC</span>})
<span id="L188" class="LineNr">188 </span>Q2R (<span class="Type">Thing</span>,<span class="Type">Thing</span>,<span class="Type">Thing</span>, <span class="Type">Thing</span>) := o -&gt; (W, X,Y,Z) -&gt; (
<span id="L189" class="LineNr">189 </span>    <span class="Statement">if</span> <span class="Identifier">instance</span>(W, <span class="Constant">RR</span>) <span class="Statement">then</span> w := W_CC <span class="Statement">else</span> w = W;
<span id="L190" class="LineNr">190 </span>    <span class="Statement">if</span> <span class="Identifier">instance</span>(X, <span class="Constant">RR</span>) <span class="Statement">then</span> x := X_CC <span class="Statement">else</span> x = X;
<span id="L191" class="LineNr">191 </span>    <span class="Statement">if</span> <span class="Identifier">instance</span>(Y, <span class="Constant">RR</span>) <span class="Statement">then</span> y := Y_CC <span class="Statement">else</span> y = Y;
<span id="L192" class="LineNr">192 </span>    <span class="Statement">if</span> <span class="Identifier">instance</span>(Z, <span class="Constant">RR</span>) <span class="Statement">then</span> z := Z_CC <span class="Statement">else</span> z = Z;
<span id="L193" class="LineNr">193 </span>    M := <span class="Identifier">matrix</span>{
<span id="L194" class="LineNr">194 </span>    {w*w+x*x-(y*y+z*z), 2*(x*y-w*z), 2*(x*z+w*y)},
<span id="L195" class="LineNr">195 </span>    {2*(x*y+w*z), w^2+y^2-(x*x+z*z), 2*(y*z-w*x)},
<span id="L196" class="LineNr">196 </span>    {2*(x*z-w*y), 2*(y*z+w*x), w^2 +z*z -(x*x+y*y)}
<span id="L197" class="LineNr">197 </span>        };
<span id="L198" class="LineNr">198 </span>    <span class="Statement">if</span> o.Normalized <span class="Statement">then</span> (1/(w^2+x^2+y^2+z^2)) * M <span class="Statement">else</span> M
<span id="L199" class="LineNr">199 </span>    )
<span id="L200" class="LineNr">200 </span>Q2R <span class="Type">List</span> := o -&gt; L -&gt; Q2R(L#0, L#1, L#2, L#3, o)
<span id="L201" class="LineNr">201 </span>
<span id="L202" class="LineNr">202 </span><span class="Comment">-- get Cayley parameters from rotation matrix</span>
<span id="L203" class="LineNr">203 </span>R2Q = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{UnNormalize=&gt;<span class="Constant">false</span>,FF=&gt;<span class="Constant">CC</span>})
<span id="L204" class="LineNr">204 </span>R2Q <span class="Type">Matrix</span> := o -&gt; R -&gt; (
<span id="L205" class="LineNr">205 </span>    <span class="Identifier">assert</span>(numcols R == 3);
<span id="L206" class="LineNr">206 </span>    <span class="Identifier">assert</span>(numrows R == 3);
<span id="L207" class="LineNr">207 </span>    c := (R_(2,1) - R_(1,2));
<span id="L208" class="LineNr">208 </span>    b := (R_(0,2) - R_(2,0));
<span id="L209" class="LineNr">209 </span>    a := (R_(1,0) - R_(0,1));
<span id="L210" class="LineNr">210 </span>    w := (1/2)*<span class="Identifier">sqrt</span>(R_(0,0)+R_(1,1)+R_(2,2)+1);
<span id="L211" class="LineNr">211 </span>    x := 1/(4*w) * c;
<span id="L212" class="LineNr">212 </span>    y := 1/(4*w) * b;
<span id="L213" class="LineNr">213 </span>    z := 1/(4*w) * a;
<span id="L214" class="LineNr">214 </span><span class="Comment">--    &lt;&lt; w^2+x^2+y^2+z^2 &lt;&lt; endl;</span>
<span id="L215" class="LineNr">215 </span>    (w, x, y, z)
<span id="L216" class="LineNr">216 </span>    )
<span id="L217" class="LineNr">217 </span>
<span id="L218" class="LineNr">218 </span>-*/// <span class="Identifier">TEST</span>
<span id="L219" class="LineNr">219 </span>R=<span class="Constant">CC</span>[W]
<span id="L220" class="LineNr">220 </span><span class="Identifier">netList</span> solveSystem {W^4-W^2+1/16}
<span id="L221" class="LineNr">221 </span>
<span id="L222" class="LineNr">222 </span><span class="Identifier">clean</span> T
<span id="L223" class="LineNr">223 </span>T=<span class="Constant">QQ</span>[a..d]
<span id="L224" class="LineNr">224 </span>R=Q2R gens T
<span id="L225" class="LineNr">225 </span>S = (R-id_(((<span class="Constant">QQ</span>)^3)))*adjugate(R+id_((<span class="Constant">QQ</span>)^3));
<span id="L226" class="LineNr">226 </span>S
<span id="L227" class="LineNr">227 </span>((<span class="Identifier">first</span> x)/(<span class="Identifier">first</span> L))*L
<span id="L228" class="LineNr">228 </span>1/<span class="Identifier">sqrt</span>(<span class="Identifier">sum</span>(x/(y-&gt;y^2)))*x
<span id="L229" class="LineNr">229 </span>L
<span id="L230" class="LineNr">230 </span>///*-
<span id="L231" class="LineNr">231 </span>
<span id="L232" class="LineNr">232 </span>
<span id="L233" class="LineNr">233 </span><span class="Comment">-- cross product of col vectors -- takes Matrice or GateMatrix pair</span>
<span id="L234" class="LineNr">234 </span>crossProduct = (y,q) -&gt; <span class="Identifier">matrix</span>{{y_(1,0)*q_(2,0)-y_(2,0)*q_(1,0)},{y_(2,0)*q_(0,0)-y_(0,0)*q_(2,0)},{y_(0,0)*q_(1,0)-y_(1,0)*q_(0,0)}}
<span id="L235" class="LineNr">235 </span>
<span id="L236" class="LineNr">236 </span>cmat = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Normalized=&gt;<span class="Constant">true</span>})
<span id="L237" class="LineNr">237 </span>cmat <span class="Type">List</span> := o -&gt; L -&gt; cmat(L#0,L#1,L#2,o)
<span id="L238" class="LineNr">238 </span>cmat (<span class="Type">Thing</span>,<span class="Type">Thing</span>,<span class="Type">Thing</span>) := o -&gt; (a,b,c) -&gt; (
<span id="L239" class="LineNr">239 </span>    tx := <span class="Identifier">matrix</span>{{0,-c,b},{c,0,-a},{-b,a,0}};
<span id="L240" class="LineNr">240 </span>    <span class="Statement">if</span> o.Normalized <span class="Statement">and</span> <span class="Statement">not</span> areEqual(L#2,0.0) <span class="Statement">then</span> tx = (-1/L#2) * tx;
<span id="L241" class="LineNr">241 </span>    tx
<span id="L242" class="LineNr">242 </span>    )
<span id="L243" class="LineNr">243 </span>
<span id="L244" class="LineNr">244 </span><span class="Comment">--</span>
<span id="L245" class="LineNr">245 </span>randomLineThroughPoints = (P, FF) -&gt; (
<span id="L246" class="LineNr">246 </span>    m := numrows P; <span class="Comment">-- m = dim + 1</span>
<span id="L247" class="LineNr">247 </span>    n := numcols P; <span class="Comment">-- n = number of points</span>
<span id="L248" class="LineNr">248 </span>    <span class="Identifier">assert</span>(m&gt;=3 <span class="Statement">and</span> m&lt;=4);
<span id="L249" class="LineNr">249 </span>    K := numericalKernel(<span class="Identifier">transpose</span> P,1e-6);
<span id="L250" class="LineNr">250 </span>    <span class="Comment">--assert(numcols K == m-n); -- true if points are distinct</span>
<span id="L251" class="LineNr">251 </span>    <span class="Identifier">transpose</span>(K * <span class="Identifier">random</span>(FF^(numcols K),FF^(m-2)))
<span id="L252" class="LineNr">252 </span>    )
<span id="L253" class="LineNr">253 </span>
<span id="L254" class="LineNr">254 </span><span class="Comment">-- constructs problem data given a PL diagram D (complete visibility)</span>
<span id="L255" class="LineNr">255 </span><span class="Comment">-- returns (camera parameters, lines, camera matrices</span>
<span id="L256" class="LineNr">256 </span><span class="Comment">-- ASSUMES: &quot;intersections&quot; are sorted</span>
<span id="L257" class="LineNr">257 </span>fabricatePair = (D, FF, nvars) -&gt; (
<span id="L258" class="LineNr">258 </span>    (nLines,nGhosts,intersections) := D;
<span id="L259" class="LineNr">259 </span>    depPoints := <span class="Identifier">set</span> {};
<span id="L260" class="LineNr">260 </span>    <span class="Comment">-- --------------------</span>
<span id="L261" class="LineNr">261 </span>    <span class="Identifier">scan</span>(nLines,l-&gt;(
<span id="L262" class="LineNr">262 </span>            ptsOnl := <span class="Identifier">positions</span>(<span class="Identifier">last</span> D,i-&gt;<span class="Identifier">member</span>(l,i));
<span id="L263" class="LineNr">263 </span>            depPoints = depPoints + <span class="Identifier">set</span> <span class="Identifier">drop</span>(ptsOnl,2);
<span id="L264" class="LineNr">264 </span>            )
<span id="L265" class="LineNr">265 </span>        );
<span id="L266" class="LineNr">266 </span>
<span id="L267" class="LineNr">267 </span>    <span class="Comment">-- see which intersections have points </span>
<span id="L268" class="LineNr">268 </span>    <span class="Comment">-- for l=0:nlines-1</span>
<span id="L269" class="LineNr">269 </span>    <span class="Comment">--     ptsOnl = positions(last D,i-&gt;member(l,i)); -- all lines containing point l</span>
<span id="L270" class="LineNr">270 </span>    <span class="Comment">--     depPpoints += all elements of ptsOnl except first two</span>
<span id="L271" class="LineNr">271 </span>    <span class="Comment">-- end</span>
<span id="L272" class="LineNr">272 </span>    <span class="Comment">-- </span>
<span id="L273" class="LineNr">273 </span>    <span class="Comment">-- For cleveland: depPoints = {}</span>
<span id="L274" class="LineNr">274 </span>    <span class="Comment">----------------------</span>
<span id="L275" class="LineNr">275 </span>    pointsOnLineIndices := <span class="Identifier">apply</span>(nLines+nGhosts, l-&gt;<span class="Identifier">positions</span>(intersections,i-&gt;<span class="Identifier">member</span>(l,i)));
<span id="L276" class="LineNr">276 </span>    <span class="Comment">-- pointsOnLineIndices(l) is the point (element of intersections) where the line l is </span>
<span id="L277" class="LineNr">277 </span>    <span class="Comment">-- free lines come last in the index</span>
<span id="L278" class="LineNr">278 </span>    worldPointsFF := <span class="Identifier">random</span>(FF^4,FF^0); <span class="Comment">-- initialize empty 4 x 0 matrix</span>
<span id="L279" class="LineNr">279 </span>    <span class="Identifier">scan</span>(#intersections,i-&gt;(
<span id="L280" class="LineNr">280 </span>            pointi := <span class="Statement">if</span> <span class="Identifier">member</span>(i,depPoints) <span class="Statement">then</span> (
<span id="L281" class="LineNr">281 </span>                li := <span class="Identifier">first</span> <span class="Identifier">select</span>(1,pointsOnLineIndices,l-&gt;<span class="Identifier">member</span>(i,l));
<span id="L282" class="LineNr">282 </span>                &lt;&lt; li &lt;&lt; endl;
<span id="L283" class="LineNr">283 </span>                a := <span class="Identifier">random</span> FF;
<span id="L284" class="LineNr">284 </span>                a*worldPointsFF_{li#0}+(1-a)*worldPointsFF_{li#1}
<span id="L285" class="LineNr">285 </span>                ) <span class="Statement">else</span> <span class="Identifier">random</span>(FF^4,FF^1);
<span id="L286" class="LineNr">286 </span>            worldPointsFF = worldPointsFF | pointi
<span id="L287" class="LineNr">287 </span>            )
<span id="L288" class="LineNr">288 </span>        );
<span id="L289" class="LineNr">289 </span>    <span class="Comment">--------------------</span>
<span id="L290" class="LineNr">290 </span>
<span id="L291" class="LineNr">291 </span>    <span class="Comment">-- for point 0:npoints-1</span>
<span id="L292" class="LineNr">292 </span>        <span class="Comment">-- generate a new random column to put into worldPointsFF </span>
<span id="L293" class="LineNr">293 </span>        <span class="Comment">-- for cleveland depPoints = {} so:</span>
<span id="L294" class="LineNr">294 </span>        pointi = <span class="Identifier">random</span>(FF^4,FF^1); <span class="Comment">-- random column</span>
<span id="L295" class="LineNr">295 </span>    <span class="Comment">-- end</span>
<span id="L296" class="LineNr">296 </span>
<span id="L297" class="LineNr">297 </span>    <span class="Comment">-- For cleveland, worldPointsFF is simply a 4xnpoints random matrix</span>
<span id="L298" class="LineNr">298 </span>    <span class="Comment">-- why 4?</span>
<span id="L299" class="LineNr">299 </span>
<span id="L300" class="LineNr">300 </span>    <span class="Comment">--------------------</span>
<span id="L301" class="LineNr">301 </span>    worldPoints := sub(worldPointsFF,<span class="Constant">CC</span>); <span class="Comment">-- worldPoints = complex(worldPoints)</span>
<span id="L302" class="LineNr">302 </span>
<span id="L303" class="LineNr">303 </span>    helperPoints := <span class="Identifier">apply</span>(pointsOnLineIndices, pp-&gt;sub(<span class="Identifier">random</span>(FF^4,FF^(2-<span class="Identifier">min</span>(2,#pp))),<span class="Constant">CC</span>));
<span id="L304" class="LineNr">304 </span>
<span id="L305" class="LineNr">305 </span>    <span class="Comment">-- helperPoints(l) = random 4 x (2 - min(2,#pointsOnLineIndices(l)));</span>
<span id="L306" class="LineNr">306 </span>    <span class="Comment">-- cleveland: </span>
<span id="L307" class="LineNr">307 </span>    <span class="Comment">--  pointsOnLineIndices {{0, 1}, {0, 2}, {1, 2}, {}}</span>
<span id="L308" class="LineNr">308 </span>    <span class="Comment">--  helperPoints  = </span>
<span id="L309" class="LineNr">309 </span>    <span class="Comment">--  {0, 0, 0, | .937872+.534252ii  .13253+.163709ii  |}</span>
<span id="L310" class="LineNr">310 </span>    <span class="Comment">--            | .272731+.0505302ii .820699+.836935ii |</span>
<span id="L311" class="LineNr">311 </span>    <span class="Comment">--            | .49818+.361877ii   .253636+.257889ii |</span>
<span id="L312" class="LineNr">312 </span>    <span class="Comment">--            | .868821+.53462ii   .111019+.888939ii |</span>
<span id="L313" class="LineNr">313 </span>
<span id="L314" class="LineNr">314 </span>    <span class="Comment">-- future (line below): may be interesting to sample space of variables differently depending on the field we fabricate data over</span>
<span id="L315" class="LineNr">315 </span>    sampleCameraParameters := <span class="Statement">for</span> i <span class="Statement">from</span> 1 <span class="Statement">to</span> nvars <span class="Statement">list</span> sub(<span class="Identifier">random</span> FF,<span class="Constant">CC</span>);
<span id="L316" class="LineNr">316 </span>    <span class="Comment">-- sampleCameraParameters = random 14 numbers as list</span>
<span id="L317" class="LineNr">317 </span>
<span id="L318" class="LineNr">318 </span>    subTable := <span class="Identifier">apply</span>(sampleCameraParameters, cameraVars, (a,b) -&gt; b=&gt;inputGate a);
<span id="L319" class="LineNr">319 </span>    <span class="Comment">-- to each pair elements in same position of cameraParameters and camera</span>
<span id="L320" class="LineNr">320 </span>    <span class="Comment">-- vars, create input gate</span>
<span id="L321" class="LineNr">321 </span>    sampleC := <span class="Identifier">apply</span>(C,cam -&gt; (
<span id="L322" class="LineNr">322 </span>            M := <span class="Identifier">mutableMatrix</span>(<span class="Constant">CC</span>, 3, 4);
<span id="L323" class="LineNr">323 </span>            evaluate(cam, <span class="Identifier">mutableMatrix</span>{sampleCameraParameters}, M);
<span id="L324" class="LineNr">324 </span>            <span class="Identifier">matrix</span> M
<span id="L325" class="LineNr">325 </span>            )
<span id="L326" class="LineNr">326 </span>            );
<span id="L327" class="LineNr">327 </span>    (
<span id="L328" class="LineNr">328 </span>        sampleCameraParameters,
<span id="L329" class="LineNr">329 </span>        <span class="Identifier">apply</span>(sampleC, cam-&gt;(
<span id="L330" class="LineNr">330 </span>                P := cam * worldPoints;
<span id="L331" class="LineNr">331 </span>                <span class="Comment">-- for l=0:3 -- for cleve</span>
<span id="L332" class="LineNr">332 </span>                <span class="Comment">--         Hl = helperPoints(l) -- empty for l = 0,1,2</span>
<span id="L333" class="LineNr">333 </span>                <span class="Comment">--         Pl = P_(pointsOnLineIndices#l) -- Pl will be a 3x2 matrix, two points on the lines</span>
<span id="L334" class="LineNr">334 </span>                <span class="Comment">--                                        -- empty for l = 4</span>
<span id="L335" class="LineNr">335 </span>                <span class="Comment">--         Pl = Pl|cam*Hl; -- cat the helper points</span>
<span id="L336" class="LineNr">336 </span>                <span class="Comment">-- end</span>
<span id="L337" class="LineNr">337 </span>                L := <span class="Identifier">matrix</span> <span class="Identifier">apply</span>(nLines+nGhosts, l-&gt;(
<span id="L338" class="LineNr">338 </span>                      Hl := helperPoints#l;
<span id="L339" class="LineNr">339 </span>                      Pl := P_(pointsOnLineIndices#l);
<span id="L340" class="LineNr">340 </span>                      Pl = Pl|cam*Hl;
<span id="L341" class="LineNr">341 </span>                      line := randomLineThroughPoints(Pl, FF);
<span id="L342" class="LineNr">342 </span>                      {(1/<span class="Identifier">norm</span>(2,line))*line} <span class="Comment">-- normalization that seemed to benefit the chicago solver</span>
<span id="L343" class="LineNr">343 </span>                       ));
<span id="L344" class="LineNr">344 </span>               (P,L)
<span id="L345" class="LineNr">345 </span>               )),
<span id="L346" class="LineNr">346 </span>       sampleC
<span id="L347" class="LineNr">347 </span>        )
<span id="L348" class="LineNr">348 </span>    )
<span id="L349" class="LineNr">349 </span>
<span id="L350" class="LineNr">350 </span><span class="Comment">-- functions which fabricate input of the form (parameter, solution)</span>
<span id="L351" class="LineNr">351 </span><span class="Comment">-- notation for supp materials is (y,c)---previous notation is (p,x)</span>
<span id="L352" class="LineNr">352 </span>encodey = (P,L,projs,FF) -&gt; (
<span id="L353" class="LineNr">353 </span>    c := <span class="Identifier">transpose</span> <span class="Identifier">matrix</span>{P};
<span id="L354" class="LineNr">354 </span>    allLines := L/<span class="Identifier">last</span>;
<span id="L355" class="LineNr">355 </span>    yIndLineMatrix := cfold(
<span id="L356" class="LineNr">356 </span>            allLines/(m-&gt;m^(<span class="Identifier">toList</span> indepLines))
<span id="L357" class="LineNr">357 </span>            );
<span id="L358" class="LineNr">358 </span>    yInd := <span class="Identifier">matrix</span>(yIndLineMatrix,<span class="Identifier">product</span> <span class="Identifier">toList</span> <span class="Identifier">size</span> yIndLineMatrix,1);
<span id="L359" class="LineNr">359 </span>    yDep := <span class="Statement">if</span> (#depLines == 0) <span class="Statement">then</span> <span class="Identifier">random</span>(<span class="Constant">CC</span>^0,<span class="Constant">CC</span>^1) <span class="Statement">else</span>
<span id="L360" class="LineNr">360 </span>    rfold(
<span id="L361" class="LineNr">361 </span>        depLines/(l-&gt; (
<span id="L362" class="LineNr">362 </span>                lineInds := <span class="Identifier">first</span> <span class="Identifier">select</span>(1,<span class="Identifier">last</span> D,i-&gt;<span class="Identifier">member</span>(l,i));
<span id="L363" class="LineNr">363 </span>                triplet := <span class="Identifier">take</span>(lineInds, 2) | {l};
<span id="L364" class="LineNr">364 </span>                rfold(allLines/(m -&gt; (
<span id="L365" class="LineNr">365 </span>                        n :=numericalKernel(<span class="Identifier">transpose</span> m^triplet, kTol);
<span id="L366" class="LineNr">366 </span>                        (1/n_(2,0))*n^{0,1}
<span id="L367" class="LineNr">367 </span>                        ))
<span id="L368" class="LineNr">368 </span>                    )
<span id="L369" class="LineNr">369 </span>                )
<span id="L370" class="LineNr">370 </span>            )
<span id="L371" class="LineNr">371 </span>        );
<span id="L372" class="LineNr">372 </span>    ytChart := sub(randKernel(<span class="Identifier">transpose</span>(c^{4*(m-1)..(4*(m-1)+3*(m-1)-1)}||<span class="Identifier">matrix</span>{{1_CC}}), FF),<span class="Constant">CC</span>);
<span id="L373" class="LineNr">373 </span>    yqChart := sub(rfold(
<span id="L374" class="LineNr">374 </span>        <span class="Statement">for</span> i <span class="Statement">from</span> 0 <span class="Statement">to</span> m-2 <span class="Statement">list</span> randKernel(<span class="Identifier">transpose</span>(c^{4*i..4*i+3}||<span class="Identifier">matrix</span>{{1_CC}}), FF)
<span id="L375" class="LineNr">375 </span>        ),<span class="Constant">CC</span>);
<span id="L376" class="LineNr">376 </span>    yInd||yDep||ytChart||yqChart
<span id="L377" class="LineNr">377 </span>    )
<span id="L378" class="LineNr">378 </span>
<span id="L379" class="LineNr">379 </span>encodeyc = (P, L, projs,FF) -&gt; (
<span id="L380" class="LineNr">380 </span>    c := <span class="Identifier">transpose</span> <span class="Identifier">matrix</span>{P};
<span id="L381" class="LineNr">381 </span>    y := encodey(P, L, projs,FF);
<span id="L382" class="LineNr">382 </span>    (point y, point c)
<span id="L383" class="LineNr">383 </span>    )
<span id="L384" class="LineNr">384 </span>
<span id="L385" class="LineNr">385 </span>fabricateyc = FF -&gt; (
<span id="L386" class="LineNr">386 </span>    (P, L, projs) := fabricatePair(D, FF, nvars); <span class="Comment">-- these variable names are confusing</span>
<span id="L387" class="LineNr">387 </span>    encodeyc(P, L, projs,FF)
<span id="L388" class="LineNr">388 </span>    )
<span id="L389" class="LineNr">389 </span>
<span id="L390" class="LineNr">390 </span><span class="Comment">-- convenience functions for minors</span>
<span id="L391" class="LineNr">391 </span><span class="Identifier">minors</span> (GateMatrix, <span class="Constant">ZZ</span>, <span class="Type">Sequence</span>, <span class="Type">Boolean</span>) := o -&gt;  (M, k, S, laplace) -&gt; (
<span id="L392" class="LineNr">392 </span>    (Sm, Sn) := (<span class="Identifier">first</span> S, <span class="Identifier">last</span> S);
<span id="L393" class="LineNr">393 </span>    (m,n) := (numrows M, numcols M);
<span id="L394" class="LineNr">394 </span>    <span class="Identifier">assert</span>(k&lt;=<span class="Identifier">min</span>(m,n));
<span id="L395" class="LineNr">395 </span>    <span class="Identifier">assert</span>(<span class="Identifier">all</span>(Sm,s-&gt;#s==k));
<span id="L396" class="LineNr">396 </span>    <span class="Identifier">assert</span>(<span class="Identifier">all</span>(Sn,s-&gt;#s==k));
<span id="L397" class="LineNr">397 </span>    <span class="Identifier">flatten</span> <span class="Identifier">apply</span>(Sm,sm-&gt;<span class="Identifier">apply</span>(Sn, sn -&gt;
<span id="L398" class="LineNr">398 </span>            <span class="Statement">if</span> (laplace) <span class="Statement">then</span> laplaceDet <span class="Identifier">submatrix</span>(M,sm,sn)
<span id="L399" class="LineNr">399 </span>            <span class="Statement">else</span> det <span class="Identifier">submatrix</span>(M,sm,sn)
<span id="L400" class="LineNr">400 </span>            ))
<span id="L401" class="LineNr">401 </span>    )
<span id="L402" class="LineNr">402 </span>
<span id="L403" class="LineNr">403 </span>allMinors = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Laplace=&gt;<span class="Constant">false</span>})
<span id="L404" class="LineNr">404 </span>allMinors (GateMatrix, <span class="Constant">ZZ</span>) := o -&gt; (M, k) -&gt; (
<span id="L405" class="LineNr">405 </span>    (m, n ) := (numrows M, numcols M);
<span id="L406" class="LineNr">406 </span>    s := (<span class="Identifier">subsets</span>(0..m-1,k),<span class="Identifier">subsets</span>(0..n-1,k));
<span id="L407" class="LineNr">407 </span>    <span class="Identifier">minors</span>(M, k, s, o.Laplace)
<span id="L408" class="LineNr">408 </span>    )
<span id="L409" class="LineNr">409 </span>
<span id="L410" class="LineNr">410 </span>maxMinors = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Laplace=&gt;<span class="Constant">false</span>})
<span id="L411" class="LineNr">411 </span>maxMinors GateMatrix := o -&gt; M -&gt; allMinors(M,<span class="Identifier">min</span>(numrows M, numcols M), Laplace=&gt;o.Laplace)
<span id="L412" class="LineNr">412 </span>
<span id="L413" class="LineNr">413 </span><span class="Comment">-- this seems to work</span>
<span id="L414" class="LineNr">414 </span>complexQR = M -&gt; (
<span id="L415" class="LineNr">415 </span>    A := <span class="Identifier">mutableMatrix</span> M;
<span id="L416" class="LineNr">416 </span>    k := <span class="Identifier">ring</span> A;
<span id="L417" class="LineNr">417 </span>    Q := <span class="Identifier">mutableMatrix</span>(k,0,0,<span class="Identifier">Dense</span>=&gt;<span class="Constant">true</span>);
<span id="L418" class="LineNr">418 </span>    R := <span class="Identifier">mutableMatrix</span>(k,0,0,<span class="Identifier">Dense</span>=&gt;<span class="Constant">true</span>);
<span id="L419" class="LineNr">419 </span>    rawQR(raw A, raw Q, raw R, <span class="Constant">true</span>);
<span id="L420" class="LineNr">420 </span>    <span class="Identifier">assert</span>(areEqual(Q*R,A)); <span class="Comment">-- idk if it will work every time!</span>
<span id="L421" class="LineNr">421 </span>    (<span class="Identifier">matrix</span> Q,<span class="Identifier">matrix</span> R)
<span id="L422" class="LineNr">422 </span>    )
<span id="L423" class="LineNr">423 </span>
<span id="L424" class="LineNr">424 </span>leverageScores = M -&gt; (
<span id="L425" class="LineNr">425 </span>    Q = <span class="Identifier">first</span> complexQR M;
<span id="L426" class="LineNr">426 </span>    <span class="Identifier">rsort</span> <span class="Identifier">apply</span>(numrows Q,i-&gt;(<span class="Identifier">norm</span>(2,Q^{i}),i))
<span id="L427" class="LineNr">427 </span>    )
<span id="L428" class="LineNr">428 </span>
<span id="L429" class="LineNr">429 </span>
<span id="L430" class="LineNr">430 </span>
<span id="L431" class="LineNr">431 </span><span class="Comment">-- indexes subsystem giving Jacobian rank</span>
<span id="L432" class="LineNr">432 </span>rowSelector = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Threshold=&gt;1e-4})
<span id="L433" class="LineNr">433 </span>rowSelector <span class="Type">Matrix</span> := o -&gt; J0 -&gt; (
<span id="L434" class="LineNr">434 </span>    (m , n) := <span class="Identifier">size</span> J0;
<span id="L435" class="LineNr">435 </span>    J0' := J0^{0}; <span class="Comment">-- should technically check this is not identically zero</span>
<span id="L436" class="LineNr">436 </span>    i := 1;
<span id="L437" class="LineNr">437 </span>    inds := <span class="Statement">new</span> <span class="Type">MutableList</span> <span class="Statement">from</span> {0};
<span id="L438" class="LineNr">438 </span>    k := numericalRank J0';
<span id="L439" class="LineNr">439 </span>    <span class="Statement">while</span> ( (i&lt;m) <span class="Statement">and</span> (k &lt; n)) <span class="Statement">do</span> (
<span id="L440" class="LineNr">440 </span>        <span class="Statement">if</span> (numericalRank(J0'||J0^{i},Threshold=&gt;o.Threshold) &gt; k) <span class="Statement">then</span> (
<span id="L441" class="LineNr">441 </span>            inds#k = i;
<span id="L442" class="LineNr">442 </span>            k = k+1;
<span id="L443" class="LineNr">443 </span>            J0' = J0'||J0^{i};
<span id="L444" class="LineNr">444 </span>            );
<span id="L445" class="LineNr">445 </span>        i = i + 1;
<span id="L446" class="LineNr">446 </span>        );
<span id="L447" class="LineNr">447 </span>    <span class="Statement">if</span> k &lt; n <span class="Statement">then</span>  &lt;&lt; &quot;WARNING: Jacobian has <span class="Identifier">rank</span>&quot; &lt;&lt; <span class="Identifier">toString</span> k &lt;&lt; endl;
<span id="L448" class="LineNr">448 </span>    <span class="Identifier">toList</span> inds
<span id="L449" class="LineNr">449 </span>    )
<span id="L450" class="LineNr">450 </span>
<span id="L451" class="LineNr">451 </span>leverageScoreRowSelector = J0 -&gt; (
<span id="L452" class="LineNr">452 </span>    sortedRows := (leverageScores J0)/<span class="Identifier">last</span>;
<span id="L453" class="LineNr">453 </span>    r := rowSelector J0^(sortedRows);
<span id="L454" class="LineNr">454 </span>    <span class="Identifier">sort</span>(r/(i-&gt;sortedRows#i))
<span id="L455" class="LineNr">455 </span>    )
<span id="L456" class="LineNr">456 </span>
<span id="L457" class="LineNr">457 </span>log10 = x -&gt; <span class="Identifier">log</span>(x)/<span class="Identifier">log</span>(10)
<span id="L458" class="LineNr">458 </span>
<span id="L459" class="LineNr">459 </span>argCC = z -&gt; <span class="Identifier">atan</span>((<span class="Identifier">imaginaryPart</span> z)/(<span class="Identifier">realPart</span> z))
<span id="L460" class="LineNr">460 </span>
<span id="L461" class="LineNr">461 </span><span class="Comment">-- complex number whose real and imag parts are standard normal</span>
<span id="L462" class="LineNr">462 </span>gaussCC = () -&gt; (
<span id="L463" class="LineNr">463 </span>    (u1,u2):=(<span class="Identifier">random</span> <span class="Constant">RR</span>,<span class="Identifier">random</span> <span class="Constant">RR</span>);
<span id="L464" class="LineNr">464 </span>    <span class="Identifier">sqrt</span>(-2*<span class="Identifier">log</span>(u1))*<span class="Identifier">cos</span>(2*<span class="Constant">pi</span>*u2)+<span class="Constant">ii</span>*<span class="Identifier">sqrt</span>(-2*<span class="Identifier">log</span>(u1))*<span class="Identifier">sin</span>(2*<span class="Constant">pi</span>*u2)
<span id="L465" class="LineNr">465 </span>    )
<span id="L466" class="LineNr">466 </span>
<span id="L467" class="LineNr">467 </span><span class="Comment">-- random sample drawn from normal distriution N(mu, var^2)</span>
<span id="L468" class="LineNr">468 </span>rNorm = (mu,var) -&gt; mu+var*(<span class="Identifier">realPart</span> gaussCC())_CC
<span id="L469" class="LineNr">469 </span>
<span id="L470" class="LineNr">470 </span><span class="Comment">-- random sample from (n-1)-sphere with radius r</span>
<span id="L471" class="LineNr">471 </span>sphere = (n,r) -&gt; (
<span id="L472" class="LineNr">472 </span>    l:=<span class="Identifier">apply</span>(n,i-&gt;rNorm(0,1));
<span id="L473" class="LineNr">473 </span>    <span class="Identifier">matrix</span>{r/<span class="Identifier">norm</span>(2,l)*l}
<span id="L474" class="LineNr">474 </span>    )
<span id="L475" class="LineNr">475 </span>
<span id="L476" class="LineNr">476 </span><span class="Comment">-- assumes &quot;u&quot; of unit length</span>
<span id="L477" class="LineNr">477 </span>householder=<span class="Identifier">method</span>()
<span id="L478" class="LineNr">478 </span>householder (<span class="Type">Matrix</span>,<span class="Constant">ZZ</span>) := (u,n) -&gt; (
<span id="L479" class="LineNr">479 </span>    <span class="Statement">if</span> (numrows u &gt; 1) <span class="Statement">then</span> <span class="Identifier">error</span>(&quot;householder takes a row <span class="Identifier">vector</span>&quot;);
<span id="L480" class="LineNr">480 </span>    R:=<span class="Identifier">ring</span> u;
<span id="L481" class="LineNr">481 </span>    k:=numcols u;
<span id="L482" class="LineNr">482 </span>    id_(R^(n-k))++(id_(R^k)-2*(<span class="Identifier">transpose</span> u)*u)
<span id="L483" class="LineNr">483 </span>    )
<span id="L484" class="LineNr">484 </span>householder (<span class="Type">List</span>,<span class="Constant">ZZ</span>) := (u,n) -&gt; householder(<span class="Identifier">matrix</span> {u},n)
<span id="L485" class="LineNr">485 </span>
<span id="L486" class="LineNr">486 </span>randomOn = n -&gt; <span class="Identifier">diagonalMatrix</span>(<span class="Identifier">toList</span>((n-1):1_RR)|{(-1)^(<span class="Identifier">random</span> 2)}) * <span class="Identifier">fold</span>(<span class="Identifier">reverse</span> <span class="Identifier">apply</span>(2..n,i-&gt;householder(sphere(i,1),n)),(a,b)-&gt;a*b)
<span id="L487" class="LineNr">487 </span>
<span id="L488" class="LineNr">488 </span>randomCameraNormalized = () -&gt; (
<span id="L489" class="LineNr">489 </span>    R := randomOn 3;
<span id="L490" class="LineNr">490 </span>    t := <span class="Identifier">matrix</span>{{<span class="Identifier">random</span> <span class="Constant">CC</span>},{<span class="Identifier">random</span> <span class="Constant">CC</span>},{<span class="Identifier">random</span> <span class="Constant">CC</span>}};
<span id="L491" class="LineNr">491 </span><span class="Comment">--    t := transpose matrix{sphere(3,1)};</span>
<span id="L492" class="LineNr">492 </span>    tnorm := (1 / t_(2,0))* t;
<span id="L493" class="LineNr">493 </span>    (R|tnorm)
<span id="L494" class="LineNr">494 </span>    )
<span id="L495" class="LineNr">495 </span>
<span id="L496" class="LineNr">496 </span>randomCameraNormalizedCayley = () -&gt; (
<span id="L497" class="LineNr">497 </span>    R := cay2R(<span class="Identifier">random</span> <span class="Constant">CC</span>, <span class="Identifier">random</span> <span class="Constant">CC</span>, <span class="Identifier">random</span> <span class="Constant">CC</span>,Normalized=&gt;<span class="Constant">true</span>);
<span id="L498" class="LineNr">498 </span>    t := <span class="Identifier">matrix</span>{{<span class="Identifier">random</span> <span class="Constant">CC</span>},{<span class="Identifier">random</span> <span class="Constant">CC</span>},{<span class="Identifier">random</span> <span class="Constant">CC</span>}};
<span id="L499" class="LineNr">499 </span><span class="Comment">--    t := transpose matrix{sphere(3,1)};</span>
<span id="L500" class="LineNr">500 </span>    tnorm := (1 / t_(2,0))* t;
<span id="L501" class="LineNr">501 </span>    (R|tnorm)
<span id="L502" class="LineNr">502 </span>    )
<span id="L503" class="LineNr">503 </span>
<span id="L504" class="LineNr">504 </span>
<span id="L505" class="LineNr">505 </span>randomCamera = () -&gt; (
<span id="L506" class="LineNr">506 </span>    R := randomOn 3;
<span id="L507" class="LineNr">507 </span>    t := <span class="Identifier">transpose</span> <span class="Identifier">matrix</span>{sphere(3,1)};
<span id="L508" class="LineNr">508 </span>    (R|t)
<span id="L509" class="LineNr">509 </span>    )
<span id="L510" class="LineNr">510 </span>
<span id="L511" class="LineNr">511 </span>ranks = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{})
<span id="L512" class="LineNr">512 </span>ranks (<span class="Type">Matrix</span>, <span class="Type">Matrix</span>) := o -&gt; (x, p) -&gt; (
<span id="L513" class="LineNr">513 </span>    <span class="Statement">if</span> (numcols x &gt; 1) <span class="Statement">then</span> x = <span class="Identifier">matrix</span>(x, numcols x,1);
<span id="L514" class="LineNr">514 </span>    <span class="Statement">if</span> (numcols p &gt; 1) <span class="Statement">then</span> p = <span class="Identifier">matrix</span>(p, numcols p,1);
<span id="L515" class="LineNr">515 </span>    a := PE/( m -&gt; (
<span id="L516" class="LineNr">516 </span>            evaluate(<span class="Identifier">first</span> m, <span class="Identifier">mutableMatrix</span>(x||p), <span class="Identifier">last</span> m);
<span id="L517" class="LineNr">517 </span>            numericalRank <span class="Identifier">matrix</span> <span class="Identifier">last</span> m
<span id="L518" class="LineNr">518 </span>            )
<span id="L519" class="LineNr">519 </span>            );
<span id="L520" class="LineNr">520 </span>    b := LE/( m -&gt; (
<span id="L521" class="LineNr">521 </span>            evaluate(<span class="Identifier">first</span> m, <span class="Identifier">mutableMatrix</span>(x||p), <span class="Identifier">last</span> m);
<span id="L522" class="LineNr">522 </span>            numericalRank <span class="Identifier">matrix</span> <span class="Identifier">last</span> m
<span id="L523" class="LineNr">523 </span>            )
<span id="L524" class="LineNr">524 </span>            );
<span id="L525" class="LineNr">525 </span>   (a, b)
<span id="L526" class="LineNr">526 </span>   )
<span id="L527" class="LineNr">527 </span>ranks (Point,Point) := o -&gt; (x,p) -&gt; ranks(<span class="Identifier">matrix</span> x, <span class="Identifier">matrix</span> p)
<span id="L528" class="LineNr">528 </span>
<span id="L529" class="LineNr">529 </span>rankCheck = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{Hard=&gt;<span class="Constant">true</span>})
<span id="L530" class="LineNr">530 </span>rankCheck (<span class="Type">Matrix</span>, <span class="Type">Matrix</span>) := o -&gt; (x, p) -&gt; (
<span id="L531" class="LineNr">531 </span>   (a, b) := ranks(x, p);
<span id="L532" class="LineNr">532 </span>   <span class="Statement">if</span> (o.Hard) <span class="Statement">then</span> (<span class="Identifier">all</span>(a,x-&gt;x==3) <span class="Statement">and</span> <span class="Identifier">all</span>(b,x-&gt;x==2))
<span id="L533" class="LineNr">533 </span>     <span class="Statement">else</span> (<span class="Identifier">all</span>(a,x-&gt;x&lt;=3) <span class="Statement">and</span> <span class="Identifier">all</span>(b,x-&gt;x&lt;=2))
<span id="L534" class="LineNr">534 </span>   )
<span id="L535" class="LineNr">535 </span>
<span id="L536" class="LineNr">536 </span>cpMatrix = t -&gt; <span class="Identifier">matrix</span>{{0,-t_(2,0),t_(1,0)},{t_(2,0),0,-t_(0,0)},{-t_(1,0),t_(0,0),0}}
<span id="L537" class="LineNr">537 </span>
<span id="L538" class="LineNr">538 </span>essential = (R,t) -&gt; R * cpMatrix t
<span id="L539" class="LineNr">539 </span>
<span id="L540" class="LineNr">540 </span>pCompose = <span class="Identifier">method</span>()
<span id="L541" class="LineNr">541 </span>pCompose (<span class="Type">MutableHashTable</span>, <span class="Type">MutableHashTable</span>) := (H1, H2) -&gt; (
<span id="L542" class="LineNr">542 </span>    <span class="Statement">new</span> <span class="Type">MutableHashTable</span> <span class="Statement">from</span> <span class="Identifier">apply</span>(<span class="Identifier">keys</span> H1,k-&gt; <span class="Statement">if</span> H2#?(H1#k) <span class="Statement">then</span> k=&gt; H2#(H1#k))
<span id="L543" class="LineNr">543 </span>    )
<span id="L544" class="LineNr">544 </span>
<span id="L545" class="LineNr">545 </span>writePermutations = <span class="Identifier">method</span>(<span class="Identifier">Options</span>=&gt;{})
<span id="L546" class="LineNr">546 </span>writePermutations (HomotopyNode, <span class="Type">String</span>) := o -&gt; (V, filename) -&gt; (
<span id="L547" class="LineNr">547 </span>    <span class="Comment">-- assume for now that G has 2 nodes</span>
<span id="L548" class="LineNr">548 </span>    G := V.Graph;
<span id="L549" class="LineNr">549 </span>    V1 := <span class="Identifier">first</span> G.Vertices;
<span id="L550" class="LineNr">550 </span>    V2 := <span class="Identifier">last</span> G.Vertices;
<span id="L551" class="LineNr">551 </span>    E1 := <span class="Identifier">toList</span> V1.Edges;
<span id="L552" class="LineNr">552 </span>    <span class="Comment">-- &quot;petal loops&quot; based at V1</span>
<span id="L553" class="LineNr">553 </span>    e1 := <span class="Identifier">first</span> E1;
<span id="L554" class="LineNr">554 </span>    perms := <span class="Identifier">apply</span>(<span class="Identifier">drop</span>(E1,1),e-&gt;<span class="Identifier">values</span> pCompose(e1.Correspondence12,e.Correspondence21));
<span id="L555" class="LineNr">555 </span>    writePermutations(perms,filename);
<span id="L556" class="LineNr">556 </span>    )
<span id="L557" class="LineNr">557 </span>writePermutations (<span class="Type">List</span>, <span class="Type">String</span>) := o -&gt; (L, filename) -&gt; (
<span id="L558" class="LineNr">558 </span>    perms := L/(P-&gt;P/(i-&gt;i+1)); <span class="Comment">-- increment letters by 1 for GAP</span>
<span id="L559" class="LineNr">559 </span>    file := <span class="Identifier">openOut</span> (currentFileDirectory | filename);
<span id="L560" class="LineNr">560 </span>    <span class="Statement">for</span> i <span class="Statement">from</span> 0 <span class="Statement">to</span> #perms-1 <span class="Statement">do</span> file &lt;&lt; &quot;p&quot; &lt;&lt; i &lt;&lt; &quot;:= PermList(&quot; &lt;&lt; <span class="Identifier">toString</span>(<span class="Statement">new</span> <span class="Type">Array</span> <span class="Statement">from</span> perms#i) &lt;&lt; &quot;);&quot; &lt;&lt; endl;
<span id="L561" class="LineNr">561 </span>    file &lt;&lt; &quot;G:=Group(&quot;;
<span id="L562" class="LineNr">562 </span>    <span class="Statement">for</span> i <span class="Statement">from</span> 0 <span class="Statement">to</span> #perms-2 <span class="Statement">do</span> file &lt;&lt; &quot;p&quot; &lt;&lt; i &lt;&lt; &quot;, &quot;;
<span id="L563" class="LineNr">563 </span>    file &lt;&lt; &quot;p&quot; &lt;&lt; #perms-1 &lt;&lt; &quot;);&quot;;
<span id="L564" class="LineNr">564 </span>    close file;
<span id="L565" class="LineNr">565 </span>    )
<span id="L566" class="LineNr">566 </span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
